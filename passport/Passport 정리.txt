# Passport

## 시작

 자사의 서비스 데이터를 읽어갈 수 있도록 하는 API를 공개했고, 이를 이용한 많은 모바일 앱들이 등장했다. 트위터를 이용하는 이용자들을 자신의 개성에 따라 트위터를 이용할 수 있게 되었다. 이로 인해 많은 기업들이 자사의 데이터를 외부에서 접속해서 사용할 수 있도록 공개하기 '시작했다'.

 문제는 인증이었다. 자사의 데이터를 가져가게 하려면 사용자의 허가가 필요한데, 이를 위해서는 사용자의 비밀번호가 필요했기 때문이다.

 이를 극복하기 위해서 정보 기술 업계에서는 OAuth, OpenID와 같은 표준화 방법을 고안하기 시작했다. 이와 같은 방법을 이용하면 사용자의 비밀번호를 제 3의 서비스에게 노출시키지 않고도 인증 기능을 구현할 수 있기 때문이다. 즉, 제 3의 서비스에게 모든 권한을 주지않고 필요한 최소한의 권한만을 부여해서 최악의 보안 사고를 막을 수 있는 안전장치를 마련할 수 있게 되었다.

 그 후로 다양한 로그인 방법들이 쏟아졌다. 페이스북, 구글, 카카오톡 등..

 그러나 이러한 인증 방법을 안전하게 구현하는 것을 매우 어려운일이다. 이러한 맥락에서 express 프레임워크에서 등장한 라이브러리가 바로 passoport다. passport는 현 시점에서 약 300가지의 인증 방법을 '전략'이라는 이름으로 제공하고 있다. 전략을 추가하는 것만으로도 복잡한 인증 방법을 손쉽게 구현할 수 있게 된 것이다. web4, express-session, auth 등 이러한 인증 기능을 passport로 전환하는 작업을 지금부터 시작한다.

내부적으로 session을 사용한다. = 따라서 express-session을 활성화시키는 코드 다음에 passport가 등장해야한다.

## 인증구현
 login Form에서 전송한 데이터를 passport가 받도록 하고, 그 때 주소(route)로 전송되는 데이터는 local strategy, 즉 ID와 PW를 통해 로그인하는 전략으로 처리하겠다. 그래서 성공했을 때는 '/'로, 실패했을 때는 다시 '/auth/login'로 보내겠다. 라는 의도가 담겨있는 코드 부분.
 사용자가 실제 이 서비스의 owner인지 아닌지를 check하는 로그인 로직이 필요하다. => 자격확인

## 자격확인
 사용자가 로그인을 했을 때 로그인에 성공했는지, 실패했는지 자격확인을 할 필요가 있다. passport.use(전략)

 첫번째 파라미터를 객체로 넣어서,  form에서 받는 name의 이름을 변경할 수 있고,
 두번째 파라미터를 콜백함수로 받아 자격확인을 할 수 있다.
 
 ###done
 false가 아닌 값을 주면 javascript는 true로 인식한다.
 두 번째 인자로 false가 아닌 객체 값을 주면 자격확인에 성공한 것이다.
 그러면 passport가 초기화되어 있어야한다.
 [ 생활코딩에서는 user, password 등의 데이터가 모두 포함된 객체를 두번째 인자로 주었다. ]

## 세션이용
 app.use()는 express에 middleware를 설치하는 것이다.
 따라서 (자격확인을 위해서) passport가 express에 설치되어있어야한다. = initialize()
 passport를 사용하면서 session을 내부적으로 사용해야한다 = session()
 이런 상태에서 로그인을 하면 성공할 수 있다. 하지만 사용자에 대한 정보를 세션으로 저장해야한다. 그러나 세션에 대한 setting이 되어있지 않다.

 passport를 내부적으로 세션을 이용해야한다.
 그래서 세션을 처리할 방법이 필요하다. = serializeUser(), deserializeUser()
 로그인에 성공했을 때 serializeUser 메소드의 인자로 전달된 콜백함수가 호출되도록 약속되어있다. 자격증명의 done의 인자로 보낸 데이터(유저 정보)를 serializeUser 메소도의 콜백 함수의 첫번째 인자로 주입해주도록 약속되어있다. 따라서 serializeUser 메소드내의 콜백함수에서는 done에다가 첫 번째는 null을 주고, 두번째 인자로는 각각의 사용자를 식별할 수 있는 식별자를 주라고 되어있다.
 그 후 세션 데이터안의 passport의 user 값으로 사용자의 식별자가 들어가게 된다.
 즉, 로그인에 성공했다는 사실을 세션 스토어에 저장하는 기능을 하는 것이다.
 로그인에 성공했을 때 단 한 번 호출된다.
 
 그러면 이제 페이지에 방문할 때마다 deserializeUser 메소드의 콜백함수가 호출되도록 약속되어있다.
 사용자가 로그인에 성공한 이후 각각의 페이지 아무곳이나 방문할 때마다 그 사람이 로그인한 사용자인지, 아닌지 확인해야하는데, 그것을 체크할 때 passport는 deseiralizeUser 메소드를 호출한다.
 즉, 세션 스토어에 저장된 데이터를 기준으로 해서 	우리가 필요한 정보를 조회할 때 사용하는 것이다.
 콜백함수가 호출될 때마다 사용자의 데이터가 저장되어있는 곳에서 사용자의 실제 데이터를 조회해서 가져온다.
 콜백함수의 첫번째 인자인 id는 세션 데이터안의 식별자다.(passport.user의 값)
 콜백함수의 두번째 인자는 done이다. done의 두번째 인자가 바로 실제 데이터(객체)다.

 이제 로그인이 되었는지 안되었는지 알아볼 필요가 있다. 

## 로그인 확인
 router에서 request의 user라는 객체(req.user)는 실제 데이터(객체)를 가지고 있다.
 이 데이터는 deserializeUser의 콜백함수의 두 번째 인자인 done의 두 번째 인자로 주입한 데이터다. done(err, DATA)
 즉, done은 router의 request로 user라는 객체로 두 번째 인자로 주입한 데이터를 전달하기로 약속되어있다. (passport를 사용하면)

 req.session_is_logined를 req.user로 바꿔주면 된다. [ 이부분 코드 확인해보기 ]

## 로그아웃
1. req.session.destroy(err => res.redirect('/')); 를
2. req.logout(); req.redirect('/')로

req.user 객체를 지운다.

 로그인을하고 로그아웃을 했을 때 로그아웃이 안되었다고 뜨는 경우가 있다. 그리고 한참 있다가 새로고침을 해보면 그 때서야 로그아웃이 된다. 이는 1번의 경우, session에서도 destroy를 하고서 콜백함수를 통해서 실제로 세션 스토어에 대한 작업이 끝난 다음에 res.redirect('/')를 호출한다. 2번의 경우도 1번과 비슷한 문제로 추정된다.
 따라서 passport를 통해 logout을 하고, 세션을 지운다음에 redirect를 해주는 것이 안전할 것으로 보인다. 이렇게 하면 logout이 시간차이에 의해서 안되는 문제는 해결된다. 그런데 또 이상한게 이상한 오류가 뜰 수 있다. 그래서 다시 코드를 바꿨는데, passport를 통해 logout을 하고, 현재의 세션 상태를 저장하고(req.session.save), 그 작업이 끝나면 redirect를 하는 것이다.

 어떤 사용자는 express-session-store들 중 하나로 사용되는 connect-loki 미들웨어를 설치해서 해결했다고 한다.
 현재는 session-file-store를 사용하고 있는 것으로 보인다.


## 플래쉬 메시지
 인증구현을 할 때 객체에 failureFlash: true를 통해 플래쉬 메세지를 활성화한다.
 이 기능은 req.flash()를 통해서 구현할 수 있다. 이를 위해 connect-falsh라는 미들웨어를 사용해야한다. [이는 passport와 상관없는 기능이다. passport가 사용하고 있는 기능일 뿐이다. ]
 connect-flash도 세션을 내부적으로 사용하고 있으므로 session 미들웨어 다음에 설치해야한다.

 req.flash(인자, 인자)를 통해 세션 스토어에 플래쉬를 저장하고, req.flash()를 통해 세션 스토어에서 플래쉬값을 플래쉬하고 삭제한다.

 1. connect-flash를 로드하고, 미들웨어로 설치하고,
 2. 이제 로그인에 성공하거나, 실패했을 때 일회용으로 어떤 문제가 있었는지 사용자에게 보인다.

 2번 과정을 하기 위해서, 인증 구현을 할 때 두 번째 인자인 객체에 failureFlash를 true로 설정한다. 그리고 '자격 확인'을 할 때 done의 세번째 인자로 객체에 message를 설정한다.

 이후, req.flash를 이용해서 message값을 저장해서 html과 같은 문서에 사용한다.
 [생활코딩에서는 fmsg라는 변수에 저장 후, fmsg.error[0]로 message를 출력했다. ]


## 결론[ 이런게 중요합니다 ]

 express 생태계에서 인증과 관련해서 중요한 역할을 맡고 있는 passport.js의 사용법을 살펴보았다.
 
 passport는 내부적으로는 express-session 미들웨어를 사용한다. 그리고 이 session 미들웨어만으로도 우리는 인증기능을 구현할 수 있다. 또 passport를 사용하기 위해서는 express-session 모듈을 어느정도는 알고 있어야할 뿐만 아니라, session만으로 구현하는 것보다도 훨씬 더 복잡하다. 이런 악조건 속에서 passport를 이용하는 이유는 무엇일까?

 passport의 진정한 가치는 300여개에 이르는 인증 전략에서 나온다. 모두 아시다시피 우리의 현실은 모두 위험한 일로 가득차있다. 이러한 현실 위에서 나쁜 일들과 다퉈야하는 인증 시스템은 자연스럽게 고도로 복잡하고, 그런 복잡성을 제대로 핸들링하지 못한다면, 극도로 위험해질 수 있다. 이러한 복잡성과 위험성을 보안 전문가가 아닌 사람이 감당하는 것은 쉽지 않다. 그래서 전문가들이 만들어낸 인증 전략을 이용하면 구글, 페이스북, 네이버, 카카오톡 등과 같은 기업의 계정을 이용해서 인증 기능을 쉽게 구현할 수 있다. 이러한 인증 방식은 'Federated Identity'(연합 식별)라고 부른다.

 Federated Identity를 이용하면 회원 정보를 우리들의 서비스에 보관하는 것이 아니라, 구글, 페이스북과 같은 유명한 기업의 서비스에게 그 사용자가 이 사용자가 맞는지를 물어보는 것을 통해서 인증을 결정할 수 있다. passport는 이를 위한 여러가지 전략을 구비해놓고 있다. 이러한 전략들을 사용하다보니까 passport는 자연스럽게 여러가지 형식들을 갖추고 있는 것이고, 바로 이 형식들이 우리에게는 어렵게 느껴진다.

 Federated Identity가 중요한 또 다른 이유가 있다. 오늘날 페이스북, 아마존과 같은 회사들은 사용자의 중요한 정보를 많이 가지고 있다. 그리고 이 회사들이 가지고 있는 시스템을 제어하는 것은 굉장히 중요한 일이 되어가고 있다. 이러한 회사들이 가지고 있는 인프라의 정보를 사용하거나, 그 인프라를 조작하는 접점을 'API'라고 부른다. 

 API에 접근하는 것은 오늘날 매우 중요한 일이 되어가고 있다. 이를 위해서는 서로간의 신뢰할 수 있는지 파악할 수 있는 인증 시스템이 필요한데, Federated Identity가 바로 API에 접근할 수 있는 권한을 부여하는 역할을 하고 있다. 그러한 의미에서 Federated Identity의 중요성은 갈수록 커져갈 것이다. 